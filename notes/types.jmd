---
title : Getting started with Julia
author : |
  Michiel Stock
  Bram De Jaegher
  Daan Van Hauwermeiren
date: December 2019
---

# Everything has a type

All Julia objects, both those already defined as well as those you migh make yourself, have a type. The type system is the secret sauce, allowing Julia to be fast because code can be specialized for a certain combination of types. It is also supremely useful in combination with *multiple dispatch*, in which functions work differently depending on which types you feed into them.

# Checking the type

The type of objects can be assessed using the function `typeof`. For collections, `eltype` gives the types of the individual elements. Try the following examples. Note that types are are always capitalized!

```julia
a = 42; s = "mice"; n = 0.9; A = [1 2; 3 4];

typeof(a)
typeof(s)
typeof(n)
typeof(A)

eltype(A)
```

All these types are *concrete types*. All Julia types are part of a hierarchical type system, forming a single, fully connected type graph. The concrete types are the leaves of this tree, whereas the inner nodes are *abstract types*. As hinted by the name, these are abstract and cannot be instantiated. They however help with conceptially ordering the type system.

We can find the supertype of a concrete or abstract type using the function `supertype`.

```julia
supertype(Int8)
supertype(Float64)
supertype(AbstractFloat)
supertype(Real)
supertype(Number)
supertype(Any)
```
See how all the number are hierarchically represented? Note that any type is always a subtype of `Any`. We can check if an object is (sub)type using the function `isa`.

```julia
a isa Int  # int is concrete type Int64
a isa Integer  # integer is abstract
a isa Int8
a isa Number
```

We can check if one type is a subtype of the second one using the binary operator `<:`.

```julia; eval=false
Float64 <: AbstractFloat
Float16 <: AbstractFloat
AbstractFloat <: Number
Int <: Number
Int <: AbstractFloat
Integer <: Int
```

# Methods and dispatch

When a function is run for the first time with a particular combinations of type inputs, it get compiled by the LLVM compiler. Such a specific function is refered to as a `method`. Every time a function is run with a new combination of types of arguments, a suitable method is compiled. This is noticible when measuring running time. Compare

```julia
mynewfun(x) = x^2 + x

A = [1 2; 3 4];

# first run
@time mynewfun(A)

# second run
@time mynewfun(A)

# now with a float
@time mynewfun(1)

# new value, same type
@time mynewfun(12)
```

The known methods can be found using the function `methods`. For example, check how many methods there are associated with the humble multiplication operator `*`.

The arguments a function can take can be restricted using the `::`-operator. Here, if we restrict a function as `f(x::T)`, this means that `x` can be any type `<: T`. Can you explain the reasoning behind the following code? How does it process numbers? What does it do with strings?

```julia
twice(x::Number) = 2x
twice(x::String) = x * x
```

> **Exercise** Can you predict the outcome of the following lines of code?

```julia
f(x, y) = println("No life forms present")
f(x::T, y::T) where {T} = x * y  # short for {T <: Any}
f(x::Integer, y::Real) = 2x + y
f(x::Int, y::Int) = 2x + 2y
f(x::Integer, y::Float64) = x + 2y
f(x::Float64, y::Real) = x - y
f(x::Float64, y::Float64) = 2x - y
```

Predict what the result will be of the following evaluations.

```julia; eval=false
f(1, 2.0)
f(1.0, 2)
f(Int8(1), Int8(2))
f(1.0, 2.0)
f("one", 2)
f("one", "two")
f(1, Float32(2.0))
f(1, 2)
f([1 1; 1 1], [2.0 2.0; 2.0 2.0])
f([1 1; 1 1], [2 2; 2 2])
```

# Defining types

Abstract types are defined using the following simple syntax:

```
abstract type «name» end
abstract type «name» <: «supertype» end
```

*Primitive types* exist of simple bits. Examples are `Float64` and `Int16`. You can declare your own types, though this is likely not something many do often in practice.

*Composite types* (records, structs, or objects) are more exiting. They are often containers for several objects set to behave in a certain way. Take the following small example of defining types.

```julia
abstract type Pet end

struct Cat <: Pet
  name
end

struct Dog <: Pet
  name
end

call(cat::Cat) = println("miaaw")
call(dog::Dog) = println("woof")

mycat = Cat("Appa")
hisdog = Dog("Storm")

call(mycat)
call(hisdog)
```

```julia
meets(pet1::Cat, pet2::Dog) = println("$(pet1.name) hisses at $(pet2.name)")
meets(pet1::Dog, pet2::Cat) = println("$(pet1.name) barks at $(pet2.name)")
meets(pet1::Cat, pet2::Cat) = println("$(pet1.name) ignors $(pet2.name)")
meets(pet1::Dog, pet2::Dog) = println("$(pet1.name) sniff the but of $(pet2.name)")

meets(mycat, hisdog)
meets(hisdog, mycat)
```

# Case study: the Strang matrix

The Strang matrix

$$
\begin{pmatrix}
  -2 & 1& \cdots & 0 & 0 \\
  1 & -2& \cdots & 0 & 0\\
  \vdots  & \vdots  & \ddots & \vdots  \\
  0 &0 & \cdots & -2 & 1\\
0 &0 & \cdots & 1 & -2
 \end{pmatrix}
$$

```julia
struct Strang <: AbstractMatrix{Int}
  n
  function Strang(n::Integer)
    @assert n > 0 throw(AssertionError("n should be positive, got $n"))
    new(n)
  end
end

Base.eltype(S::Strang) = Int
Base.size(S::Strang) = (S.n, S.n)
Base.getindex(S::Strang, i, j) = i==j ? -2 : (abs(i-j)==1 ? 1 : 0)
```

That's it! Now, we have our own implementation of the Strang matrix. We have also given Julia just enough information such that it can also represent this nicely!

```julia
S = Strang(5)
```

Note that many other functionality just magically appears.

```julia
v = collect(1:5)
S * v
```

> **Assignment** Though multiplication works, it is quite slow, because Julia has no sense of the special structure of Strang matrices. Overload the `*` function in Julia to provide quick multiplication.

```julia; eval=false
function Base.*(S::Strang, v::Vector)
  ...
end
```
