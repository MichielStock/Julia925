---
title : Project: 1D elementary cellular automata
author : |
  Michiel Stock
  Bram De Jaegher
  Daan?
date: December 2019
---

In this exercise, we will simulate elementary one-dimensional cellular automata.

# What are elementary cellular automata?



# A basic implementation

## Update rule

We start with implementing the updating rule from a single state to the next. This can be implemented in a variety of ways, but let us provide one that is reasonable concise and efficient. It will also nicely illustrate some aspects of Julia's type system.

Updating a cell depends only on the state of the cell and its two neighbors. Let us use three Boolean variables `(l, s, r)` to denote them. Here `s` is the state of the cell of interest and `l` and `r` are the states of its left and right neighbor, repsectively. The rule can be represented by an integer between 0 and 255, hence an 8-bit number. The rule for updating a state is implemented below.

```julia
nextstate(l::Bool, s::Bool, r::Bool, rule::Int8) = bitstring(rule)[8-(4r+2s+1r)] == '1'
```

Here, we have cleverly made use of the function `bitstring`, which transforms an 8-bit number in the corresponding bitstring.

! @show bitstring(Int(8))

The three Boolean variables are transformed in the correct index of this string. We might save ourselves the bother of ensuring that the argument `rule` is of the type `Int8` using dispatch.

```julia
nextstate(l::Bool, s::Bool, r::Bool, rule::Integer) = nextstate(l, s, r, Int8(rule))
```

> **Assignment**: Create a 256 by 3 matrix `S` containing all possible states of three adjacent cells. Complete the function `nextstates`, which returns a vector containing the next state of the middle cell.

```julia; eval=false
S = ...

function nextstates(S, rule)
  ...
  return states
end
```

## Simulating a 1D CA model

We will represent the states of our system using a binary vector (type is `BitVector`) `x`.
Efficient functions often work inplace. We will construct a function `next!`, which takes the current state vector `x` and a vector to store the next states in a binary vector `xnew` for a given rule. This function uses cyclic boundaries.

> **Assignment**: Complete the function `next!`.

```julia; eval=false
"""
  next!(xnew, x, rule)

Updates a state vector `x` according to `rule` and stores the result in `xnew`.
"""
function next!(xnew, x, rule)
  ...
  return xnew
end
```

> **Optional assignment**: Make a simular function `next`, which only takes as arguments `x` and `rule`, i.e. this function allocates a new vector for the result.

Now that we can simulate a single time step, let us write a function to simulate for several time steps.

```julia; eval=false
"""
    simulate(x₀, rule; nsteps::Integer=100)

Simulate `nsteps` time steps according to `rule` with `x₀` as the initial condition.
Returns a matrix X, where the rows are the state vectors at different time steps.
"""
function simulate(x₀, rule; nsteps::Integer=100)
    ...
    return X
end
```

> **Assignments**
> 1. Complete the funtion `simulate`.
> 2. Choose a number for the rule. Simulate a elementary CA of size 101 for 100 time steps. Start from a vector with all elements false, except for the middle cell.
> 3. Visualize the result. This can be done using `heatmap(1X)` (multiplying by 1 turns the Booleans into numerical values).

# Type-based dispatch for rules
